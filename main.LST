C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 1   


C51 COMPILER V6.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE .\main.c DEBUG OBJECTEXTEND

stmt level    source

   1          #include "reg932.h"
   2          #include "uart.h"
   3          #include <stdlib.h>
   4          sbit mole0_0 = P2 ^ 4; //LEDs
   5          sbit mole0_1 = P0 ^ 5;
   6          sbit mole0_2 = P2 ^ 7;
   7          sbit mole1_0 = P0 ^ 6;
   8          sbit mole1_1 = P1 ^ 6;
   9          sbit mole1_2 = P0 ^ 4;
  10          sbit mole2_0 = P2 ^ 5;
  11          sbit mole2_1 = P0 ^ 7;
  12          sbit mole2_2 = P2 ^ 6;
  13          
  14          sbit hole0_0 = P2 ^ 0; //Buttons
  15          sbit hole0_1 = P0 ^ 1;
  16          sbit hole0_2 = P2 ^ 3;
  17          sbit hole1_0 = P0 ^ 2;
  18          sbit hole1_1 = P1 ^ 4;
  19          sbit hole1_2 = P0 ^ 0;
  20          sbit hole2_0 = P2 ^ 1;
  21          sbit hole2_1 = P0 ^ 3;
  22          sbit hole2_2 = P2 ^ 2;
  23          
  24          sbit strike1 = P3 ^ 0;//Strike outs
  25          sbit strike2 = P3 ^ 1;
  26          
  27          sbit speaker = P1 ^ 7;//Speaker / buzzer
  28          
  29          code const unsigned char DIFFICULTY_ONE = 20;
  30          code const unsigned char DIFFICULTY_TWO = 40;
  31          code const unsigned char DIFFICULTY_THREE = 60;
  32          
  33          
  34          void delay(); //Simple delay function, used almost everywhere
  35          void strikeOut(unsigned char s); //Turns on the LED's on the breadboard based on numStrikes
  36          void clearStrikes(); //turns off all strike LED's upon the ending of a game
  37          void getTone(); //displays a tone on a successful mole
  38          void missTone();  //Displays a tone on a missed mole
  39          void ft1();//a series of tones for the gameover conditions
  40          void ft2();//^
  41          void ft3();//^
  42          void ft4();//^
  43          void endBuzzer(); //implements the ft<1-4> functions
  44          void endGame(); //sends a game over message to the monitor serially
  45          void sendData(char score); //Sends the score serially to the monitor
  46          void setLED(unsigned char row, unsigned char col); //Sets the specified LED (sets it to 0)
  47          void clearLED(unsigned char row, unsigned char col); //Clears the specified LED (sets it to 1)
  48          unsigned char getHole(unsigned char row, unsigned char col); //Gets the current value for the button
  49          unsigned char wait(int difficulty, unsigned char row, unsigned char col); //Will return 1 if the button is
             - pressed on time
  50          void setPorts(void); //Making sure the LED's work on the simon-board by setting them into bi-directional m
             -ode
  51          unsigned char userUnlock(); //Must unlock the simon board by pressing the 'Game' button 3 times
  52          void printWelcome();//prints welcome message
  53          void buzz() interrupt 1 {
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 2   

  54   1      
  55   1      speaker = ~speaker;
  56   1      
  57   1      }
  58          
  59          void main(void) {
  60   1      
  61   1          unsigned int difficulty; //using the max demay for a timer, this is the number of loops that we will w
             -ait for at max time
  62   1          unsigned char menu = 0; //Var to decide if the game is over (main loop control var)
  63   1      	unsigned char gameOver = 0; //determines whether or not the game is over
  64   1      	unsigned char row = 0; //The random row selected
  65   1      	unsigned char col = 0; //The random column selected
  66   1      	unsigned char score = 0; //The score that the user has accumulated
  67   1      	unsigned char result = 0; //Determines whether or not hte wait function returned a 
  68   1      	unsigned char strikes = 0; //The current num of strikes the user has accumulated
  69   1      	unsigned char startGame = 0; //Determines whether or not hte game will start based on the code entered, j
             -ust press the game LED ()
  70   1      	unsigned char randSeed = 0;
  71   1      	setPorts(); //has to be called after these variables are declared
  72   1      	uart_init();
  73   1      
  74   1      	clearStrikes();
  75   1      	
  76   1          startGame = userUnlock();
  77   1      	if(startGame == 1){
  78   2          while (1) {
  79   3      	    printWelcome();
  80   3      		setLED(0, 0); //Difficulty One
  81   3          	setLED(0, 1); //Difficulty Two
  82   3          	setLED(0, 2); //Difficulty Three
  83   3            
  84   3      	  do { //Main Menu Loop
  85   4              //Should probably do this all in a function to keep our Main clean
  86   4              if (!getHole(0, 0)) {
  87   5                difficulty = DIFFICULTY_ONE;//Hard - Magic
  88   5      		  menu = 1;
  89   5              } else if (!getHole(0, 1)) {
  90   5                difficulty = DIFFICULTY_TWO;//Medium - Magic
  91   5      		  menu = 1;
  92   5              } else if (!getHole(0, 2)) {
  93   5                difficulty = DIFFICULTY_THREE;//Easy - Magic
  94   5      		  menu = 1;
  95   5              }
  96   4            } while (!menu);
  97   3      	  clearLED(0, 0); //Clears the Difficulty LED's
  98   3      	  clearLED(0, 1);
  99   3      	  clearLED(0, 2);
 100   3      	  //Game Loop
 101   3      	  
 102   3      	  do {
 103   4      	    randSeed++;
 104   4      	    randSeed = rand();
 105   4      	    srand(randSeed);
 106   4      		row = rand() % 3;
 107   4      		col = rand() % 3;
 108   4      		setLED(row, col);
 109   4      		result = wait(difficulty, row, col); //Calls the wait function to determine whether or not the user pres
             -sed the button on time
 110   4      		if(result) {
 111   5      			score++;
 112   5      			sendData(score); //sends the score to the monitor
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 3   

 113   5      			getTone(); //Plays the correct tone
 114   5      			//Send Score to Serial
 115   5      		}
 116   4      		else {
 117   5      			//Light up ohe LED on breabdoard
 118   5      			strikes++;
 119   5      			missTone(); //Plays a tone for a missed button press
 120   5      			missTone();
 121   5      			missTone();
 122   5      			strikeOut(strikes);
 123   5      			if(strikes == 3)
 124   5      				gameOver = 1;
 125   5      		}
 126   4      		clearLED(row, col); //Clears the randomly Selected Mole
 127   4      		delay(); //Adds delay so the game is possible
 128   4      		delay();
 129   4      	  }while(!gameOver);
 130   3      
 131   3      	  endGame();
 132   3      	  endBuzzer();
 133   3      	  clearStrikes();
 134   3      	  menu = 0;
 135   3      	  strikes = 0;
 136   3      	  score = 0;
 137   3      	  gameOver = 0;
 138   3       
 139   3          }
 140   2      	}
 141   1        } //End main
 142          
 143          void setLED(unsigned char row, unsigned char col) {
 144   1        switch (row) {
 145   2        	case 0:
 146   2          {
 147   3            switch (col) {
 148   4            case 0:
 149   4              mole0_0 = 0;
 150   4              break;
 151   4            case 1:
 152   4              mole0_1 = 0;
 153   4              break;
 154   4            case 2:
 155   4              mole0_2 = 0;
 156   4              break;
 157   4            } //end switch col
 158   3          } //end case 0
 159   2          break;
 160   2        case 1:
 161   2          {
 162   3            switch (col) {
 163   4            case 0:
 164   4              mole1_0 = 0;
 165   4              break;
 166   4            case 1:
 167   4              mole1_1 = 0;
 168   4              break;
 169   4            case 2:
 170   4              mole1_2 = 0;
 171   4              break;
 172   4            } //end switch col
 173   3          } //end case 1
 174   2          break;
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 4   

 175   2        case 2:
 176   2          {
 177   3            switch (col) {
 178   4            case 0:
 179   4              mole2_0 = 0;
 180   4              break;
 181   4            case 1:
 182   4              mole2_1 = 0;
 183   4              break;
 184   4            case 2:
 185   4              mole2_2 = 0;
 186   4              break;
 187   4            } //end switch col
 188   3          } //end case 2
 189   2          break;
 190   2        } //end case switch
 191   1      }
 192          
 193          void clearLED(unsigned char row, unsigned char col) {
 194   1        switch (row) {
 195   2        case 0:
 196   2          {
 197   3            switch (col) {
 198   4            case 0:
 199   4              mole0_0 = 1;
 200   4              break;
 201   4            case 1:
 202   4              mole0_1 = 1;
 203   4              break;
 204   4            case 2:
 205   4              mole0_2 = 1;
 206   4              break;
 207   4            } //end switch col
 208   3          } //end case 0
 209   2          break;
 210   2        case 1:
 211   2          {
 212   3            switch (col) {
 213   4            case 0:
 214   4              mole1_0 = 1;
 215   4              break;
 216   4            case 1:
 217   4              mole1_1 = 1;
 218   4              break;
 219   4            case 2:
 220   4              mole1_2 = 1;
 221   4              break;
 222   4            } //end switch col
 223   3          } //end case 1
 224   2          break;
 225   2        case 2:
 226   2          {
 227   3            switch (col) {
 228   4            case 0:
 229   4              mole2_0 = 1;
 230   4              break;
 231   4            case 1:
 232   4              mole2_1 = 1;
 233   4              break;
 234   4            case 2:
 235   4              mole2_2 = 1;
 236   4              break;
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 5   

 237   4            } //end switch col
 238   3          } //end case 2
 239   2          break;
 240   2        } //end case switch
 241   1      }
 242          
 243          unsigned char getHole(unsigned char row, unsigned col) //Gets the value for the button
 244            {
*** WARNING C235 IN LINE 244 OF .\MAIN.C: parameter 2: different types
 245   1          switch (row) {
 246   2          case 0:
 247   2            {
 248   3              switch (col) {
 249   4              case 0:
 250   4                return ((unsigned char) hole0_0);
 251   4                break;
 252   4              case 1:
 253   4                return ((unsigned char) hole0_1);
 254   4                break;
 255   4              case 2:
 256   4                return ((unsigned char) hole0_2);
 257   4                break;
 258   4              } //end switch col
 259   3            } //end case 0
 260   2            break;
 261   2          case 1:
 262   2            {
 263   3              switch (col) {
 264   4              case 0:
 265   4                return ((unsigned char) hole1_0);
 266   4                break;
 267   4              case 1:
 268   4                return ((unsigned char) hole1_1);
 269   4                break;
 270   4              case 2:
 271   4                return ((unsigned char) hole1_2);
 272   4                break;
 273   4              } //end switch col
 274   3            } //end case 1
 275   2            break;
 276   2          case 2:
 277   2            {
 278   3              switch (col) {
 279   4              case 0:
 280   4                return ((unsigned char) hole2_0);
 281   4                break;
 282   4              case 1:
 283   4                return ((unsigned char) hole2_1);
 284   4                break;
 285   4              case 2:
 286   4                return ((unsigned char) hole2_2);
 287   4                break;
 288   4              } //end switch col
 289   3            } //end case 2
 290   2            break;
 291   2          } //end case switch
 292   1        }
 293          
 294          unsigned char wait(int difficulty, unsigned char row, unsigned char col) //Boolean is not a default type i
             -n C. Will return 1 if button is pressed on time
 295            {
 296   1          unsigned int index;
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 6   

 297   1          TMOD = 0x01;
 298   1      	
 299   1      
 300   1          for (index = 0; index < difficulty; index++) {
 301   2      	  TH0 = 0x00;
 302   2            TL0 = 0x00; //These delays must be observable by humans, so difficulty will be number of loops
 303   2            TR0 = 1;
 304   2            while (!TF0) //wait for the max time
 305   2            {
 306   3              if (getHole(row, col) == 0) //buttons are low if pressed, getHole will generate some overhead
 307   3              {
 308   4                TR0 = 0; //Stop timer
 309   4                TF0 = 0; //Reset overflow
 310   4                return 1; //Return 1 is presses
 311   4              } //end if
 312   3            } //end while
 313   2      	  TF0 = 0;
 314   2      	  TR0 = 0;
 315   2          } //end for, difficulty 
 316   1          return 0; //button was never pressed			
 317   1        } //end wait function
 318          
 319          void setPorts(void) {
 320   1        P0M1 = 0x00; //Set ports 0, 1, and 2 into bi-mode - comment out until it's ready for the simon2
 321   1        P0M2 = 0x00;
 322   1        P1M1 = 0x00;
 323   1        P1M2 = 0x00;
 324   1        P2M1 = 0x00;
 325   1        P2M2 = 0x00;
 326   1        P3M1 = 0x00;
 327   1        P3M2 = 0x00;
 328   1      }
 329          
 330          
 331          void delay() {
 332   1      	unsigned int i = 0;
 333   1      	TMOD = 0x10;
 334   1      	for(i = 0; i < 40; i++) {
 335   2      		TH1 = 0xF0;
 336   2      		TL1 = 0x00;
 337   2      		TR1 = 1;
 338   2      		while(TF1 == 0);
 339   2      		TR1 = 0;
 340   2      		TF1 = 0;	
 341   2      	
 342   2      		}
 343   1      	
 344   1      	return;
 345   1      }
 346          
 347          
 348          void getTone() {//C ^ 6, 1046 Hz, (1/1046) = 0.00096s = 960us, 960us/(1.085/6*) = 5309 *(This microcontrol
             -ler is 6 times faster than the standard 8051)
 349   1      	TMOD = 0x01;
 350   1      	TH0 = 0xEB;
 351   1      	TL0 = 0x42;
 352   1      	EA = 1;
 353   1      	ET0 = 1;
 354   1      	TR0 = 1;
 355   1      	delay();
 356   1      	TR0 = 0;
 357   1      	TF0 = 0;
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 7   

 358   1      	ET0 = 0;
 359   1      
 360   1      	return;
 361   1      }
 362          
 363          void missTone() {
 364   1      	TMOD = 0x01;
 365   1      	TH0 = 0xFF;
 366   1      	TL0 = 0xFF;
 367   1      	EA = 1;
 368   1      	ET0 = 1;
 369   1      	TR0 = 1;
 370   1      	delay();
 371   1      	TR0 = 0;
 372   1      	TF0 = 0;
 373   1      	ET0 = 0;
 374   1      
 375   1      	return;
 376   1      }
 377          
 378          void ft1() {//concert F
 379   1      	TMOD = 0x01;
 380   1      	TH0 = 0x0F;
 381   1      	TL0 = 0x8D;
 382   1      	EA = 1;
 383   1      	ET0 = 1;
 384   1      	TR0 = 1;
 385   1      	delay();
 386   1      	TR0 = 0;
 387   1      	TF0 = 0;
 388   1      	ET0 = 0;
 389   1      
 390   1      	return;
 391   1      }
 392          void ft2() {//concert E
 393   1      	TMOD = 0x01;
 394   1      	TH0 = 0x10;
 395   1      	TL0 = 0x68;
 396   1      	EA = 1;
 397   1      	ET0 = 1;
 398   1      	TR0 = 1;
 399   1      	delay();
 400   1      	TR0 = 0;
 401   1      	TF0 = 0;
 402   1      	ET0 = 0;
 403   1      
 404   1      	return;
 405   1      }
 406          void ft3() {//concert Eb
 407   1      	TMOD = 0x01;
 408   1      	TH0 = 0x11;
 409   1      	TL0 = 0x47;
 410   1      	EA = 1;
 411   1      	ET0 = 1;
 412   1      	TR0 = 1;
 413   1      	delay();
 414   1      	TR0 = 0;
 415   1      	TF0 = 0;
 416   1      	ET0 = 0;
 417   1      
 418   1      	return;
 419   1      }
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 8   

 420          void ft4() {//concert D
 421   1      	TMOD = 0x01;
 422   1      	TH0 = 0x12;
 423   1      	TL0 = 0x5C;
 424   1      	EA = 1;
 425   1      	ET0 = 1;
 426   1      	TR0 = 1;
 427   1      	delay();
 428   1      	TR0 = 0;
 429   1      	TF0 = 0;
 430   1      	ET0 = 0;
 431   1      
 432   1      	return;
 433   1      }
 434          void endBuzzer(void){
 435   1      	  ft1();
 436   1      	  delay();
 437   1      	  ft1();
 438   1      	  delay();
 439   1      	  ft2();
 440   1      	  delay();
 441   1      	  ft2();
 442   1      	  delay();
 443   1      	  ft3();
 444   1      	  delay();
 445   1      	  ft3();
 446   1      	  delay();
 447   1      	  ft4();
 448   1      	  delay();
 449   1      	  ft4();
 450   1      	  delay();
 451   1      	  ft4();
 452   1      	  delay();
 453   1      	  ft4();
 454   1      	  delay();
 455   1      }
 456          void sendData(char score) {
 457   1      unsigned char i = 0;
 458   1      char temp = 0;
 459   1      char sc[10] = "Score :";
 460   1      //lower = score & 0x0F;
 461   1      //upper = score & 0xF0;
 462   1      //upper = (lower > 9) ? (upper+1) : (upper);
 463   1      //upper = (upper % 10) + 0x30;
 464   1      //lower = (lower % 10) + 0x30;
 465   1      temp = ((score / 10) << 4) | (score % 10);
 466   1      
 467   1      while(sc[i] != '\0'){
 468   2      	uart_transmit(sc[i]);
 469   2      	i++;
 470   2      }
 471   1      
 472   1      i = 0;
 473   1      uart_transmit(((temp & 0xF0) >> 4) + 0x30);
 474   1      uart_transmit((temp & 0x0F) + 0x30);
 475   1      uart_transmit('\r');
 476   1      uart_transmit('\n');
 477   1      
 478   1      
 479   1      }
 480          
 481          void strikeOut(unsigned char s) {
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 9   

 482   1       switch(s){
 483   2         case 1:
 484   2           strike1 = ~strike1;
 485   2      	 break;
 486   2         case 2:
 487   2           strike2 = ~strike2;
 488   2      	 break;
 489   2       }
 490   1       delay();
 491   1      }
 492          
 493          void clearStrikes(void){
 494   1        strike1 = ~strike1;
 495   1        strike2 = ~strike2;
 496   1      }
 497          
 498          void endGame() {
 499   1      
 500   1      	unsigned char i = 0;
 501   1      	char sc[10] = "Game Over!";
 502   1      	for(i = 0; i < 10; i++)
 503   1      		uart_transmit(sc[i]);
 504   1      	for(i = 0; i < 5; i++) {
 505   2      		uart_transmit('\r');
 506   2      		uart_transmit('\n');
 507   2      	}
 508   1      }
 509          
 510          unsigned char userUnlock(){
 511   1        unsigned char row, col;
 512   1        unsigned char numPresses;
 513   1        unsigned char randSeeder;
 514   1        row = col = randSeeder = 0;
 515   1        numPresses = 0;
 516   1        while(numPresses < 3){
 517   2          randSeeder++;
 518   2          randSeeder = rand();
 519   2      	srand(randSeeder);
 520   2          row = rand() % 3;
 521   2      	col = rand() % 3;
 522   2      	setLED(row,col);
 523   2          if(!getHole(1,1)){
 524   3      	  numPresses++;
 525   3      	}
 526   2      	delay();
 527   2      	delay();
 528   2      	delay();
 529   2      	clearLED(row, col);
 530   2        }
 531   1        return 1;
 532   1      }
 533          void printWelcome(){
 534   1        unsigned char i = 0;
 535   1        char msg[75] = "Welcome to Whack-a-mole! -- red for hard, yellow for medium, green for easy";
 536   1        for(i = 0; i < 75; i++)
 537   1          uart_transmit(msg[i]);
 538   1        for(i = 0; i < 3; i++){
 539   2          uart_transmit('\r');
 540   2      	uart_transmit('\n');
 541   2        }
 542   1        return;
 543   1      }
C51 COMPILER V6.02  MAIN                                                                   05/08/2017 12:25:06 PAGE 10  

 544          
 545          
 546          
 547          
 548          
 549          
 550          
 551          
 552          
 553          
 554          
 555          
 556          
 557          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1195    ----
   CONSTANT SIZE    =     98    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     118
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
